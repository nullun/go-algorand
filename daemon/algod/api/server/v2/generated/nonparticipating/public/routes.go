// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Disassemble program bytes into the TEAL source code.
	// (GET /v2/applications/{application-id}/disassemble)
	GetApplicationDisassembly(ctx echo.Context, applicationId uint64, params GetApplicationDisassemblyParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetApplicationDisassembly converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationDisassembly(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationDisassemblyParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationDisassembly(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/disassemble", wrapper.GetApplicationDisassembly, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
